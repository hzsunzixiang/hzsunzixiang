# <center>RSA加密算法的数学原理</center>

<div style="text-align: center;">之第一篇: RSA加密算法的数学原理 </div> 


<div style="text-align: right;">孙自翔 </div> 
<div style="text-align: right;">ericksun@tencent.com</div> 
<div style="text-align: right;">haichengsun123@163.com</div> 

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

**说明**: 本系列文章从数学的角度，阐述RSA算法所涉及的数论方面的各个知识点，并且以C代码演示加密和解密的过程，最后说明RSA密码系统的安全性。    
所以这一系列共有三篇文章 
  
**第一篇** RSA加密算法的数学原理  
**第二篇** RSA加密算法的C代码实践    
**第三篇** RSA密码系统的安全性

**本文是第一篇**   文章首先简要介绍并推导RSA加密算法,然后分述各数学知识点；最后利用这些数学知识点再次总结RSA加密算法的整体数学推导过程。
<ol>   <!---定义有序列表 这个很重要-->

## <li> 密码学术语介绍

<!--
这里是注释显示不出来
{\rm 需转换的部分字符}
$$ evidence\_{i}=\sum \_{j}W\_{ij}x\_{j}+b\_{i} $$
其中，\\( W\_i \\) 和 \\( b\_i \\) 分别为类别 \\( i \\) 的权值和偏置。
\\( {\cal  K}   {\rm A}   \alpha　A　\beta　B　\gamma　\Gamma　\delta　\Delta　\epsilon　E \varepsilon　　\zeta　Z　\eta　H　\theta　\Theta　\vartheta \iota　I　\kappa　K　\lambda　\Lambda　\mu　M　\nu　N \xi　\Xi　o　O　\pi　\Pi　\varpi　　\rho　P \varrho　　\sigma　\Sigma　\varsigma　　\tau　T　\upsilon　\Upsilon \phi　\Phi　\varphi　　\chi　X　\psi　\Psi　\omega　\Omega  \\))
\\({\cal K} {\sf K}\\)
\\[\alpha\\]
-->

密码系统是指包含可能的明文信息的有限集合 \\({\cal P}\\)，可能的密文信息的有限集合\\({\cal L}\\)，可能的密钥的密钥空间\\({\cal K}\\)，以及对于密钥空间\\({\cal K}\\)里的每一个密钥\\({k}\\)，存在加密函数\\(E\_k\\)和对应的解密函数\\(D\_k\\)，使得任意的明文信息\\(x\\)满足\\(D\_k(E\_k(x))=x\\)。

## <li> RSA算法推导过程
首先把RSA算法的推导过程阐述如下，后面逐一阐述推导过程所用到的每个数学知识点。
> RSA密码系统是基于模指数的公钥密码系统，其中公钥是有一个整数\\(e\\)和两个大素数的乘积生成的模数\\(n\\)组成的数对
> $$公钥为(e,n) ,    \ \ \ \    且n=pq, \ \ 其中p和q是大素数$$
> $$且(e,\varphi(n))=1$$
> $$由欧拉公式,\ \ \ \ 其中 \varphi(n)=\varphi(p)\varphi(q)=(p-1)(q-1)$$
> 解密过程需要知道\\(e\\)模\\(\varphi(n)的逆d\\),也就是
> $$ed \equiv 1 (mod\ \varphi(n))$$
> \\(d\\)就是所谓的密钥，由于
> $$(e,\varphi(n))=1， $$
> 所以密钥\\(d\\)是存在的。  
> 为了加密信息，首先将字母转为其等价数值的数据组。  
> 为了加密明文数据组中的数据P，我们通过加密变换\\(E(P)\\)生成密文数据C:
> $$E(P)=C \equiv P^e(mod\ n),\ 0\leq C < n$$
> 为了解密密文数据C，我们利用解密变换,来获取明文P
> $$P=D(E(P))=D(C) \equiv C^d(mod \ n), 0\leq D(C)<n$$
> 证明过程如下：
> $$D(E(P))=D(C)=C^d \equiv (P^e)^d=P^{ed} \equiv P^{k\varphi(n)+1} \equiv P^{\varphi(n)k}P(mod\ n)$$
> 其中\\(ed=k\varphi(n)+1\\)对某个整数\\(k\\)成立，这是因为\\(ed\equiv1(mod\ \varphi(n))\\)，  
> 当\\((P,n)=1\\)时由欧拉定理可知\\(P^{\varphi(n)}\equiv 1(mod \ n)\\),故
> $$P^{\varphi(n)k}P \equiv (P^{\varphi(n)})^{k}P \equiv P(mod\ n)$$
> 所以  
> $$D(E(P)) \equiv P(mod\ n)$$
> 命题得证

## <li> 数论概念及定理阐述 
<ol>
### <li> 整除 
<!--摘自书籍--> 

一个整数可以被另一个整数整除的概念在数论中处于中心地位.

**定义** 如果\\(a\\)和\\(b\\)为整数且\\(a \neq 0\\), 我们说\\(a\\)整除\\(b\\)是指存在整数\\(c\\)使得\\(b=ac\\).如果\\(a\\)整除\\(b\\)，我们还称\\(a\\)是\\(b\\)的一个因子,且称\\(b\\)是\\(a\\)的倍数.

如果\\(a\\)整除\\(b\\),则将其记为\\(a \mid b\\),如果\\(a\\)不能整除\\(a\\),则将其记为 \\(a \nmid b\\)

比如：\\(13 \mid 182\\)，\\(-5\mid30\\)，\\(6 \nmid 44\\)，\\(7 \nmid 50\\)
### <li> 素数

### <li> 最大公因子
 
辗转相除法
### <li>线性丢番图方程
**定理** 设\\(a,b\\)是整数 
### <li> 模除  
<!--摘自wiki百科-->
**定义** 模除是一种不具交换性的二元运算。在C语言中用 \\(\%\\)表示。



> 当 \\(a = bq + r\\)， \\(q\\)是整数，并使其达到最大，此时我们说\\(a\\)模除\\(b\\)等于\\(r\\)。(\\(r\ \)为非负数)。

> 以数学式子表示：\\(a模除b = a-\left\lfloor \frac{a}{b}\right\rfloor \times b\\)。

> 例如要计算\\(100模除16\\)，由于\\(100\div16\\)是一个大于6且不大于7的数，取\\(q=6\\)。结果为\\(100-16\times6=4\\)。



### <li> 同余  
<!--\cite{WEBSITE:congruence_modulo}-->
同余的语言使得人们能用类似于处理等式的方式来处理整数关系。


 
**定义** 设m是正整数. 若\\(a和b\\)是整数,且 \\(m \mid (a-b)\\)
 

同余(英语：congruence modulo，符号：\\(\equiv\\))是数论中的一种等价关系。当两个整数除以同一个正整数，若得相同余数，则二整数同余。同余是抽象代数中的同余关系的原型。最先引用同余的概念与“≡”符号者为德国数学家高斯。
### <li>线性同余方程
设\\(x\\)是未知数，形如
$$ax \equiv b(mod \ m)$$
的同余式称为_一元线性同余方程_.    
线性同余方程\\(ax \equiv b(mod\ m)\\)等价于二元线性丢番图方程\\(ax-my=b\\)，整数\\(x\\)是\\(ax \equiv b(mod\ m)\\)的解当且仅当存在\\(y\\)使得\\(ax-my=b\\)    
**定理7.1** \\(\ \ \ \ \ \ \ \ 设a,b和m 是整数，m>0，(a,m)=d.若d \nmid b，则ax \equiv b(mod\ m)无解.若d \mid b， 则ax \equiv b(mod\ m)恰有d个模m不同余的解\\)
> 定理证明略。 其中要用到线性丢番图的解的结论。     

 
**推论7.1.1** \\(若a和m>0互素，且b是整数，则线性同余方程ax\equiv b(mod \ m)有模m的唯一解\\)
> **证明** 因为\\((a,m)=1，所以(a,m)|b\\)，因此，由上述定理，线性同余方程\\(ax \equiv b(mod\ m)\\)恰有\\((a,m)=1\\)个模\\(m\\)不同余的解。


### <li>模的逆(模逆元、模反元素) 
**模的逆** 考虑特殊形式的同余方程 \\(ax \equiv 1(mod \ m)\\),由上述线性同余方程给出的结论知，此方程有解当且仅当\\((a,m)=1\\),而且其所有的解都模\\(m\\)同余。       
**定义** \\(给定整数a，且满足(a,m)=1，称ax \equiv 1(mod \ m)的一个解为a模m的逆\\)
> **举例说明** \\(因为7x \equiv 1(mod\ 31)的一个解为9, 所以所有解x满足x \equiv 9(mod\ 31)\\);  
> \\(也即9和所有与9模31同余的整数，都是7模31的逆，而且只有这些整数才是7模31的逆。\\)  
> \\(比如9+31=40, 9+31\times2=71\\)    
> \\(易知7\times40\equiv1(mod\ 31)，7\times71\equiv1(mod\ 31)\\)


**记法** \\(\ \ \ a的模m的逆记为a^{-1}或者\overline{a}，则有aa^{-1}\equiv 1(mod\ m)或者a\overline{a} \equiv 1(mod\ m)\\)    
**举例说明**    
> \\(令a=7， 7\times9\equiv1(mod\ 31)，7\times40\equiv1(mod\ 31)\\)    
>\\( 则9和40都是7模31的逆元，即\overline{a}=9,或者a^{-1}=9\\)  
>\\(更精确的描述应该是\overline{a}\equiv 9(mod\ 31)或者a^{-1}\equiv 9(mod \ 31)\\)        


**得出如下结论**
> \\(若a\_{1},a\_{2}...a\_{k}...是a模m的逆，则有\\)
> \\(\overline{a}\equiv a^{-1}\equiv a\_{1} \equiv a\_{2}\equiv...\equiv a\_{k}\equiv...(mod\ m)\\)
> \\(而且只有与\overline{a}模m同余的这些整数才是a模m的逆\\)

后续的欧拉定理对模的逆做更进一步探讨。

### <li>欧拉定理   
欧拉定理在RSA加密算法中处于核心地位.  
**定义** 设\\(n\\)是一个正整数，**欧拉\\(\varphi函数\varphi(n)\\)**定义为不超过\\(n\\)且与\\(n\\)互素的正整数的个数。
<center> 欧拉函数\\(\varphi(n)\\)的值， \\(1\leq n \leq 12\\)  </center>  

|               n|   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|\\(\varphi(n)\\)|   1|   1|   2|   2 |   4|   2|   6|   4|   6|   4|  10|   4|
在证明欧拉之前，我们需要准备一些基础知识.  
**定义** 模\\(n\\)的既约剩余系是由\\(\varphi(n)\\)个整数构成的集合，集合中的每个元素均与\\(n\\)互素，且任何两个元素模\\(n\\)不同余。  
> **一些信息**: 模\\(n\\)的既约剩余系元素的个数为\\(\varphi(n)\\), 且对任意元素\\(x\\)有 \\((x,n)=1, 即x和n互素\\)  
**举例** 集合\\(\\{ 1, 3, 5, 7 \\}\\) 是模8的一个既约剩余系，集合\\(\\{-3，-1，1，3\\}\\)也是模8的一个既约剩余系。

**定理** 设\\(r\_{1},r\_2,...r\_{\varphi(n)}\\)是模\\(n\\)的一个既约剩余系，若\\(a\\)是一个正整数且\\((a,n)=1\\),那么集合\\(ar\_{1},ar\_2,...ar\_{\varphi(n)}\\)也是模\\(n\\)的一个既约剩余系。  
证明过程如下:
> 按照既约剩余系的定义，只需证明两点,  
> \\(\bigodot\\) 集合中的每个元素\\(ar\_{j}\\)均与\\(n\\)互素，也就是\\((r\_{j},n)=1\\)，证明中用到.  
> \\(\bigodot\\) 集合中的任何两个元素模\\(n\\)不同余。  
> **先证明第一点**,   
> 假设\\((ar\_{j},n)>1\\),那么\\((ar\_{j},n)\\)有一个素因子\\(p\\).  
> 因此或者\\(p \mid a\\)或者\\(p \mid r\_{j}\\).   
> 从而有或者\\(p \mid a\\)且\\(p \mid n\\),或者\\(p \mid r\_{j}\\)且\\(p \mid n\\)  
>     
> 如果\\(p \mid a\\)且\\(p \mid n\\)， 则有\\((a,n)\geq p > 1\\),跟假设\\((a,n)=1\\)矛盾。  
> 如果\\(p \mid r\_{j}\\)且\\(p \mid n\\)，\\((r\_j,n)\geq p > 1\\),同样跟假设\\((r\_{j},n)=1\\)矛盾。  
> **再证明第二点**  
> 为了证明\\(ar\_j模n\\)彼此不同余，  
> 设\\(ar\_j \equiv ar\_k(mod\ n)\\),其中\\(j和k\\)是两个不同的正整数且   
> \\(1 \leq j \leq \varphi(n) \\),\\(1 \leq k \leq \varphi(n) \\)。  
> 因\\((a,n)=1\\),由推论(TODO)知\\(r\_j \equiv r\_k(mod\ n)\\)。  
> 这跟\\(r\_j 和 r_k\\)是模\\(n\\)的既约剩余系中的元素矛盾.也就是跟定义矛盾。
> 故定理得证。

**欧拉定理** 设\\(m\\)是一个正整数，\\(a\\)是一个整数且\\((a,m)=1\\),那么\\(a^{\varphi(m)}\equiv 1(mod\ m)\\)  
**证明** 
> 令\\(r\_1,r\_2,..., r_{\varphi(n)}\\)是由不超过\\(m\\)且和\\(m\\)互素的元素组成的既约剩余系。  
> 由定理TODO，因为 \\((a,m)=1\\), 故集合\\(ar\_1,ar\_2,...,ar\_\varphi(n)\\)也是模\\(m\\)的一个既约剩余系。  
> 因此,若把每个既约剩余系中的所有项都乘起来，可得 (根据定理4.6 TODO)       
> $$  ar\_1ar\_2...ar\_{\varphi(m)} \equiv r\_1r\_2...r\_{\varphi(m)}(mode\ m)$$
> 因而  
> $$  a^{\varphi(m)}r\_1r\_2...r\_{\varphi(m)} \equiv r\_1r\_2...r\_{\varphi(m)}(mode\ m)$$
> 因为  
> $$  (r\_1r\_2...r\_{\varphi(m)}，m)=1$$  
> 故由推论(4.5.1TODO)，知，\\(a^{\varphi(m)}\equiv 1(mod\ m)\\)
> 定理得证。

**一点说明**
> \\(这里的a和m不要求为素数，只要满足(a,m)=1\\)
> 而后面的费马小定理则要求模数是素数.
>

**举例说明**

>\\(令a = 4， m = 9，满足(a,m)=1且\varphi(9)=6\\)       
>此时有
>\\(a^{\varphi(m)} =4^{6}=4096 \equiv 1(mod \ 9)\\)


可以利用欧拉定理来找寻模m的逆，若\\(a\\)和\\(m\\)互素则，
$$a \cdot a^{\varphi(m)-1}=a^{\varphi(m)}\equiv 1(mod\ m)$$
因此，\\(a^{\varphi(m)-1}\\) 是\\(a\\)模\\(m\\)的逆。

**举例说明**
> 
> \\(7x \equiv 1(mod\ 10)，求x\\)    
> \\(令a=7，m=10，此时有(a,m)=1，\varphi(m)=\varphi(10)=4，所以\\)    
> \\(7模10的逆为7^{\varphi(10)-1}=7^{3}=343\equiv 3(mod\ 10)\\)    
> \\(所以7模10的逆x\equiv 3(mod10)\\)

**结论** 结合模的逆和欧拉定理,我们有如下结论    
> \\(若a\_{1},a\_{2}...a\_{k}...是a模m的逆，则有\\)
> \\(a^{\varphi(m)-1}\equiv \overline{a}\equiv a^{-1}\equiv a\_{1} \equiv a\_{2}\equiv...\equiv a\_{k}\equiv...(mod\ m)\\)
> \\(而且只有与\overline{a}模m同余的这些整数才是a模m的逆\\)

后面我们统一用\\(\overline{a}\\)记为\\(a模m\\)的逆。 

   
结合同余中有关定理我们可以证明如下定理:  
\(注:这个定理是我自己推导出来的，RSA算法中暂时用不到这个结论，可以先略过，后续的文章中会用到。\)    
**定理** \\(若a，b，k和m是整数，(a,m)=1，则\overline{a}^{k} \equiv \overline{a^{k}} \equiv a^{-k} (mod \ m) ,其中\overline{a}为a模m的逆，即a\overline{a}\equiv 1 (mod \ m).\\)
>**证明**    
>\\(首先(a,m)=1，保证了a模m的逆\overline{a}存在\\)    
>由前面的结论知
>$$a^{\varphi(m)-1}\equiv \overline{a}(mod \ m)$$
>两边同取\\(k\\)次方
>$$\overline{a}^{k}\equiv (a^{\varphi(m)-1})^{k} =(a^{k})^{\varphi(m)-1} \equiv \overline{a^{k}}(mod \ m)$$
>

**举例说明**
> \\(以3x \equiv 1(mod\ 5)为例\\)  
> \\(令a=3，\overline{a}=2，m=5，k=3\\)      
> \\(\overline{a}^{3}=2^{3}=8 \equiv 3(mod \ 5)\\)  
> \\(而a^{3}=3^{3}=27\\)    
> \\(27y \equiv 1(mod \ 5)，用扩展欧几里得算法或者欧拉公式求出y\equiv 3(mod5)\\)  
> \\(也就是\overline{a}^{3}\equiv \overline{a^{3}} \equiv3(mod \ 5) \\)
 

### <li>欧拉函数的性质  
**定理10.1** 
$$如果p是素数，那么\varphi(p)=p-1.反之，如果p是正整数且满足\varphi(p)=p-1，那么p是素数.$$ 
> 根据欧拉函数的定义，这个是显然的.    
>

**定理10.2**
$$设m和n是互素的正整数，即(m,n)=1，那么\varphi(mn)=\varphi(m)\varphi(n)$$

###<li> 费马小定理
**注**：书籍上会先引进并证明_费马小定理_，然后再证明_欧拉定理_，这里把_费马小定理_看成_欧拉定理_的特殊情况来证明。   
_**费马小定理**_在证明_**RSA算法**_的其中一种情况时用到。    
**定理11.1(费马小定理)**  \\(设p是一个素数，a是一个正整数且(a,p)=1，则a^{p-1} \equiv 1(mod \ p)\\)    
> **证明**     
> 由定理10.1 \\(因为p是素数，所以有\varphi(p)=p-1\\)    
> 根据欧拉定理     
> $$a^{p-1} = a^{\varphi(p)}\equiv 1(mod\ p)$$
> 所以    
> $$a^{p-1}  \equiv 1(mod\ p)$$


**举例说明**
>
>\\(令a = 2， p = 7，满足p是素数且(a,p)=1\\)       
>此时有
>\\(a^{p-1} =2^{7-1}=64 \equiv 1(mod \ 7)\\)


</ol>   <!---跟三级标题匹配--> 

## <li>RSA算法  
有了以上这些结论，我们可以推导出RSA加密算法.

 
### 公钥和私钥的的生成步骤
> **RSA公钥和密钥生成**    
> **输出** : 公钥\\((e,n)和私钥d\\)    
> 1. 选择两个大素数\\(p和q\\)，则一定有\\((p,q)=1\\)  
> 2. 计算 \\(n=pq\\)    
> 3. 计算\\(\varphi(n)=\varphi(pq)=\varphi(p)\varphi(q)=(p-1)(q-1)\\)    
> 4. 选择整数\\(e\\)，使得\\((e,\varphi(n))=1\\)    
> 5. 计算满足以下条件的私钥\\(d\\)    
> $$d \cdot e \equiv 1 \ \ mod(\varphi(n))$$
>
>其中,第3步是依据定理10.1,10.2而得    
>根据推论7.1.1，第4步可以保证\\(e模\varphi(n)的模逆元d\\)存在，      
>在选择\\(e的过程中，如果(e,\varphi(n)) \not= 1\\),则选择一个新的\\(e\\)值，并重复此过程.       



>加密报文X 属于[0,n) 
>两种情况 \\((X,n)=1, (X,n)\not=1\\)
>第一种情况用欧拉定理证明
>第二种情况用费马小定理结合同余的一个定理4.9得出结论
>


### RSA算法的证明
xxx

$$\not \equiv a$$
</ol>   <!---匹配二级标题--> 







