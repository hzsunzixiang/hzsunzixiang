# <center>Elgamal加密和签名算法-第一部分</center>
 


<div style="text-align: right;">孙自翔 </div> 
<div style="text-align: right;">haichengsun123@163.com</div> 

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

**写在前面**: Elgamal加密算法(也就是离散对数签名算法DSA)是基于离散对数公钥密码体系的算法。本文分为两部分，第一部分介绍离散对数相关概念，包括阶，原根，群等概念.本文既能充分阐述算法所需要的数学知识，又不纠缠于细节；既能阐述其推导过程，又不过分扩展无关知识。非常适合程序员或公钥加密算法爱好者阅读。
   
 


<!--
这里是注释显示不出来
{\rm 需转换的部分字符}
$$ evidence\_{i}=\sum \_{j}W\_{ij}x\_{j}+b\_{i} $$
其中，\\( W\_i \\) 和 \\( b\_i \\) 分别为类别 \\( i \\) 的权值和偏置。
\\( {\cal  K}   {\rm A}   \alpha　A　\beta　B　\gamma　\Gamma　\delta　\Delta　\epsilon　E \varepsilon　　\zeta　Z　\eta　H　\theta　\Theta　\vartheta \iota　I　\kappa　K　\lambda　\Lambda　\mu　M　\nu　N \xi　\Xi　o　O　\pi　\Pi　\varpi　　\rho　P \varrho　　\sigma　\Sigma　\varsigma　　\tau　T　\upsilon　\Upsilon \phi　\Phi　\varphi　　\chi　X　\psi　\Psi　\omega　\Omega  \\))
\\({\cal K} {\sf K}\\)
\\[\alpha\\]    
\in 
a^b
--> 
## 概述  
<!-- <ol>  加上这里 一级标题不能对齐-->

### <li> 基于\\(Z_{p}\\)的离散对数问题（\\(DLP\\)）
DSA签名算法所依赖的数学根基即为离散对数问题，先阐述如下，本篇文章即围绕此定义展开。     

**定义** \\(给定一个阶为p-1的有限循环群 Z\_{p},一个本原元(原根) \alpha \in Z\_{p}和另一个元素 \beta \in Z\_{p}. \\) 
\\(DLP是确定满足以下条件的整数x(其中 1\leq x \leq p-1的问题\\)
$$\alpha^x \equiv \beta \ \ mod \ p $$

面对此定义，我们不禁有如下问题:  
1. 什么是`阶`,阶为\\(p-1\\)意味着什么?   
2. 什么是`原根`?   
3. 什么是`有限循环群`?  
4. \\(p\\)如何选择，为什么一定有满足上述定义的\\(x\\)存在    
本文的目的就是为了清晰的阐述这一`有诸多陌生术语的`定义。
 

### <li> 了解`原根`等相关知识的必要性

上述定义已经展示，要理解此定义及证明\\(x\\)的存在性，必须了解原根等相关知识。


### <li> 了解`群论`相关知识的必要性
只了解数论相关知识，而不了解群论，一样可以把Elgamal加密算法阐述清楚，但实际使用的签名算法（DSA）是Elgamal签名算法的变种，而这个变种的基础就是子群的概念。    
### <li> 数论和群论的关系(作者观点)
本文先阐述原根等数论相关知识，在此基础上给出群论等相关定义。数论的相关定义和定理可以帮助我们很好的理解群论相关概念。

## 原根
 
介绍`原根`，需要先介绍`阶`的概念，从而需要先复习下`欧拉定理`，重述如下:
### <li>欧拉定理      
**定义** 设\\(n\\)是一个正整数，**欧拉\\(\varphi函数\varphi(n)\\)**定义为不超过\\(n\\)且与\\(n\\)互素的正整数的个数。
<center> 欧拉函数\\(\varphi(n)\\)的值， \\(1\leq n \leq 12\\)  </center>  

|               n|   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|\\(\varphi(n)\\)|   1|   1|   2|   2 |   4|   2|   6|   4|   6|   4|  10|   4|


**欧拉定理** 设\\(m\\)是一个正整数，\\(a\\)是一个整数且\\((a,m)=1\\),那么\\(a^{\varphi(m)}\equiv 1(mod\ m)\\)  
**证明** 参考《初等数论及其应用》

**一点说明**
> \\(这里的a和m不要求为素数，只要满足(a,m)=1\\)
> 而后面的费马小定理则要求模数是素数.
>

**举例说明**

>\\(令a = 4， m = 9，满足(a,m)=1且\varphi(9)=6\\)       
>此时有
>\\(a^{\varphi(m)} =4^{6}=4096 \equiv 1(mod \ 9)\\)


可以利用欧拉定理来找寻模m的逆，若\\(a\\)和\\(m\\)互素则，
$$a \cdot a^{\varphi(m)-1}=a^{\varphi(m)}\equiv 1(mod\ m)$$
因此，\\(a^{\varphi(m)-1}\\) 是\\(a\\)模\\(m\\)的逆。

**举例说明**
> 
> \\(7x \equiv 1(mod\ 10)，求x\\)    
> \\(令a=7，m=10，此时有(a,m)=1，\varphi(m)=\varphi(10)=4，所以\\)    
> \\(7模10的逆为7^{\varphi(10)-1}=7^{3}=343\equiv 3(mod\ 10)\\)    
> \\(所以7模10的逆x\equiv 3(mod10)\\)

**结论** 结合模的逆和欧拉定理,我们有如下结论    
> \\(若a\_{1},a\_{2}...a\_{k}...是a模m的逆，则有\\)
> \\(a^{\varphi(m)-1}\equiv \overline{a}\equiv a^{-1}\equiv a\_{1} \equiv a\_{2}\equiv...\equiv a\_{k}\equiv...(mod\ m)\\)
> \\(而且只有与\overline{a}模m同余的这些整数才是a模m的逆\\)

后面我们统一用\\(\overline{a}\\)记为\\(a模m\\)的逆。 

### <li>整数的阶
**定义** 设\\(a\\)和 \\(n\\)是互素的整数，\\(a \not=0,n>0  \\).使得\\(a^x \equiv 1 (mod \  n)\\)成立的最小正整数\\(x\\)称为\\(a模n的阶\\)，并记为\\(ord\_{n}a\\).   
      
**说明:** 根据欧拉定理，如果\\(n\\)为正整数且\\(a\\)是一个和\\(n\\)互素的整数，那么\\(a^{\varphi(n)}\equiv 1(mod\ n)\\)，因此至少存在一个整数\\(x\\)满足这个同余方程.所以存在一个最小的正整数\\(x\\)满足这个同余方程\\(a^x \equiv 1 (mod \ n)\\)，故有如上定义。   

      
**示例1:**  为求出2模7的阶，我们计算2的各次幂模7的最小正剩余，有：
         $$2^1 \equiv 2 (mod \ 7)$$
         $$2^2 \equiv 4 (mod \ 7)$$
         $$2^3 \equiv 1 (mod \ 7)$$
         因此有\\(ord\_{7}2 =3\\), 注意此时 \\(ord\_{7}2 < \varphi(7)=6\\),    
    
**示例2:** 为求出3模7的阶，我们计算3的各次幂模7的最小正剩余，有：
         $$3^1 \equiv 3 (mod \ 7)$$
         $$3^2 \equiv 2 (mod \ 7)$$
         $$3^3 \equiv 6 (mod \ 7)$$
         $$3^4 \equiv 4 (mod \ 7)$$
         $$3^5 \equiv 5 (mod \ 7)$$
         $$3^6 \equiv 1 (mod \ 7)$$
         因此有\\(ord\_{7}3 =6\\), 注意此时 \\(ord\_{7}3 = \varphi(7)=6\\),  
         所以并不总是有    \\(ord\_{n}a = \varphi(n)\\), 跟 \\(a\\)的具体值有关.      
                    
**引子**  给特定一个整数\\(n\\), 我们对模\\(n\\)阶为\\(\varphi(n)\\)的整数\\(a\\)感兴趣，也即模\\(n\\)的最大可能阶(\\(ord\_{n}a = \varphi(n)\\))。从而引出原根的定义。          
### <li>原根  
## 群论
 
### <li> 密钥生成过程
\\(  输出：公钥：k_{pub}=(e,n) 和私钥: k\_{pr}=(d,n)  \\)

\\( 1. 选择两个大素数p和q\\)     
\\( 2. 计算n=p\cdot q\\)     
\\( 3. 计算\varphi(n)=\varphi(p)\varphi(q)=(p-1)(q-1)\\)     
\\( 4. 选择满足以下条件的公钥e\in\\{1,2,....,\varphi(n)-1\\}， 使得\\)     
$$(e,\varphi(n))=1 \ \ \ \ 即e和\varphi(n)互素,下同$$
  \\(注意：实际的选择可以大于\varphi(n)\\)        
\\( 5. 计算满足以下条件的私钥d\\)  
$$d\cdot e \equiv 1 \ mod \ \varphi(n)$$    

 
### <li> 加解密实例1-较小的指数
Alice想要发送一个加密后的消息给Bob。首先，Bob执行步骤1~5计算RSA参数，并将他的公钥发给Alice。Alice然后将消息(x=4)加密，并将得到的密文y发送给Bob。最后Bob使用他自己的私钥解密y。     
**Alice有消息发送给Bob**    
>\\(消息x=4\\)
     
**Bob生成公钥和私钥**
>\\(1. 选择素数p=3和q=11\\)    
>\\(2. 计算n=p\cdot q =33\\)    
>\\(3. 计算\varphi(n)=\varphi(p)\varphi(q)=(3-1)(11-1)=20\\)    
>\\(4. 选择公钥 e =3, 使得 (e,\varphi(n))=(3,20)=1\\)    
>\\(5. 计算d=e^{-1}\ \equiv 7\ mod\ 20， 也就是d\cdot e \equiv 1\ mod\ 20\\)   
>\\(此时得到公钥(e,n)=(3,33), 私钥 (d) = 7 , 并把公钥公布于众\\) 

**Alice拿到Bob的公钥\\((e,n)=(3,33)\\)**
> \\(y=x^e\equiv4^3\equiv mod \ 33\\)    

**Bob收到Alice发送的密文\\(y=31\\),根据私钥d恢复明文**
> \\(x=y^d=31^7\equiv4 \mod \ 33\\) 即明文为4
>
 
### <li> 加解密实例2-较大的指数
小素数并不安全，目前2048位的素数才足够安全。给出一组16bit的例子。

**一个16bit的例子**
>\\(1. 选择素数p=211和q= 223\\)    
>\\(2. 计算n=p\cdot q = 47053\\)    
>\\(3. 计算\varphi(n)=\varphi(p)\varphi(q)=(211-1)(223-1)=46620\\)    
>\\(4. 选择公钥 e = 65537, 使得 (e,\varphi(n))=(65537, 46620)=1\\)    
>\\(5. 计算d=e^{-1}\ \equiv 39653\ mod\ 47053， 也就是d\cdot e \equiv 1\ mod\ \varphi(n)\\)    
>  $$65537*39653\%46620=1$$ 
>\\(此时得到公钥(e,n)=(65537, 47053), 私钥 (d) = 39653 \\) 



## 重要定理阐述 
<ol>

### <li>欧拉定理   
欧拉定理在RSA加密算法中处于核心地位. 用来证明RSA算法的一般情形.      
**定义** 设\\(n\\)是一个正整数，**欧拉\\(\varphi函数\varphi(n)\\)**定义为不超过\\(n\\)且与\\(n\\)互素的正整数的个数。
<center> 欧拉函数\\(\varphi(n)\\)的值， \\(1\leq n \leq 12\\)  </center>  

|               n|   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|\\(\varphi(n)\\)|   1|   1|   2|   2 |   4|   2|   6|   4|   6|   4|  10|   4|


**欧拉定理** 设\\(m\\)是一个正整数，\\(a\\)是一个整数且\\((a,m)=1\\),那么\\(a^{\varphi(m)}\equiv 1(mod\ m)\\)  
**证明** 参考《初等数论及其应用》

**一点说明**
> \\(这里的a和m不要求为素数，只要满足(a,m)=1\\)
> 而后面的费马小定理则要求模数是素数.
>

**举例说明**

>\\(令a = 4， m = 9，满足(a,m)=1且\varphi(9)=6\\)       
>此时有
>\\(a^{\varphi(m)} =4^{6}=4096 \equiv 1(mod \ 9)\\)


可以利用欧拉定理来找寻模m的逆，若\\(a\\)和\\(m\\)互素则，
$$a \cdot a^{\varphi(m)-1}=a^{\varphi(m)}\equiv 1(mod\ m)$$
因此，\\(a^{\varphi(m)-1}\\) 是\\(a\\)模\\(m\\)的逆。

**举例说明**
> 
> \\(7x \equiv 1(mod\ 10)，求x\\)    
> \\(令a=7，m=10，此时有(a,m)=1，\varphi(m)=\varphi(10)=4，所以\\)    
> \\(7模10的逆为7^{\varphi(10)-1}=7^{3}=343\equiv 3(mod\ 10)\\)    
> \\(所以7模10的逆x\equiv 3(mod10)\\)

**结论** 结合模的逆和欧拉定理,我们有如下结论    
> \\(若a\_{1},a\_{2}...a\_{k}...是a模m的逆，则有\\)
> \\(a^{\varphi(m)-1}\equiv \overline{a}\equiv a^{-1}\equiv a\_{1} \equiv a\_{2}\equiv...\equiv a\_{k}\equiv...(mod\ m)\\)
> \\(而且只有与\overline{a}模m同余的这些整数才是a模m的逆\\)

后面我们统一用\\(\overline{a}\\)记为\\(a模m\\)的逆。 

   
 

### <li>欧拉函数的性质  
**定理** 
\\(如果p是素数，那么\varphi(p)=p-1.反之，如果p是正整数且满足\varphi(p)=p-1，那么p是素数.\\)
> 根据欧拉函数的定义，这个是显然的.    

**定理**
\\(设m和n是互素的正整数，即(m,n)=1，那么\varphi(mn)=\varphi(m)\varphi(n)\\)

###<li> 费马小定理
**注**：书籍上会先引进并证明_费马小定理_，然后再证明_欧拉定理_，这里把_费马小定理_看成_欧拉定理_的特殊情况来证明。   
_**费马小定理**_在证明_**RSA算法**_的其中一种情况时用到。    
**定理(费马小定理)**  \\(设p是一个素数，a是一个正整数且(a,p)=1，则a^{p-1} \equiv 1(mod \ p)\\)    
> **证明**     
> \\(因为p是素数，所以有\varphi(p)=p-1\\)    
> 根据欧拉定理     
> $$a^{p-1} = a^{\varphi(p)}\equiv 1(mod\ p)$$
> 所以    
> $$a^{p-1}  \equiv 1(mod\ p)$$
> 
 

###<li> 辅助定理
此定理可以在不引入中国剩余定理的情况下证明RSA算法的特殊情形.   
定理为《初等数论及其应用》中的推论4.9.1 的一中特殊情况。   
**定理**  \\(若a\equiv b(mod \ m\_1), a\equiv b(mod\ m\_2)， 其中a，b是整数，（m\_1,m\_2）=1, 则\\)  
$$a\equiv b(mod \  m\_1m\_2)$$  
   


</ol>   <!---跟三级标题匹配--> 

## RSA算法证明
有了以上这些结论，我们可以推导出RSA加密算法.

 
### 重述：公钥和私钥的的生成步骤
> **RSA公钥和密钥生成**    
> **输出** : 公钥\\((e,n)和私钥d\\)    
> 1. 选择两个大素数\\(p和q\\)，则一定有\\((p,q)=1\\)  
> 2. 计算 \\(n=pq\\)    
> 3. 计算\\(\varphi(n)=\varphi(pq)=\varphi(p)\varphi(q)=(p-1)(q-1)\\)    
> 4. 选择整数\\(e\\)，使得\\((e,\varphi(n))=1\\)    
> 5. 计算满足以下条件的私钥\\(d\\)    
> $$d \cdot e \equiv 1 \ \ mod(\varphi(n))$$
>
>其中,第3步是依据欧拉函数的性质可得   
>第4步的要求可以保证\\(e模\varphi(n)的模逆元d\\)存在，      
>在选择\\(e的过程中，如果(e,\varphi(n)) \not= 1\\),则选择一个新的\\(e\\)值，并重复此过程.       



>加密报文X 属于[0,n) 
>两种情况 \\((x,n)=1, (x,n)\not=1\\)
>第一种情况用欧拉定理证明
>第二种情况用费马小定理结合以上的辅助定理得出结论
>


### RSA算法的证明
有了以上铺垫，RSA算法的证明水到渠成

RSA算法即是要证明以下等式成立    
$$  d\_{k\_{pr}} (y) = d_{k\_{pr}}(e\_{k\_{pub}}(x))\equiv(x^e)^d\equiv x^{de} \equiv x (mod \ n) $$

 
**证明**

由公钥和私钥的生成规则可知
$$d \cdot e \equiv 1 (mod \ \varphi(n))$$, 此表达式等价于    
$$d \cdot e \equiv 1 + t\cdot\varphi(n) \ 其中t \in Z_{n}$$
代入等式可得

$$  d\_{k\_{pr}} (y) \equiv x^{de} \equiv x^{1+t\dot\varphi(n)}  \equiv x^{t\dot\varphi(n)}\cdot x^1 \equiv (x^{\varphi(n)})^t  \cdot x (mod \ n)$$


**分两种情况证明**

**第一种情况**  
$$若(x,n)=1$$
根据欧拉定理   立即可得
$$x^{\varphi(n)} \equiv 1  $$ 继而

$$(x^{\varphi(n)})^{t} \equiv 1  $$
所以
$$  d\_{k\_{pr}} (y) \equiv x^{de} \equiv x^{1+t\dot\varphi(n)}  \equiv x^{t\dot\varphi(n)}\cdot x^1 \equiv (x^{\varphi(n)})^t  \cdot x \equiv x (mod \ n)$$




**第二种情况** 
 $$若(x,n) = (x, p\cdot q) \not=1$$
 分别证明 
$$  d\_{k\_{pr}} (y) \equiv  x (mod \ p)$$
$$  d\_{k\_{pr}} (y) \equiv  x (mod \ q)$$
由辅助定理可得
 $$ d\_{k\_{pr}} (y) \equiv  x \ (mod \ p\cdot q)$$
即s
 $$ d\_{k\_{pr}} (y) \equiv  x \ (mod \ n)$$
只要证明其中之一即可,首先证明 \not  
>$$  d\_{k\_{pr}} (y) \equiv  x (mod \ p)$$

此时亦分两种情况    
*情况一 使用费马小定理* 
>$$x \not \equiv 0 (mod\ p) \Rightarrow (x,p) =1$$
此时有
$$  d\_{k\_{pr}} (y)  \equiv x^{t\dot\varphi(n)}\cdot x^1  \equiv x^{t(p-1)(q-1)}  \cdot x \equiv (x^{p-1})^{t(q-1)} \cdot x(mod \ p)$$
由费马小定理    
$$(x,p)=1，则x^{p-1} \equiv 1(mod \ p)$$
可得
$$  d\_{k\_{pr}} (y)  \equiv (x^{p-1})^{t(q-1)} \cdot x \equiv x(mod \ p)$$


*情况二*
>$$x  \equiv 0 (mod\ p)$$
>可得
 $$d\_{k\_{pr}} (y)  \equiv x^{ed} \equiv 0  \equiv x(mod\ p)$$

算法得证