# <center>数字签名算法(DSA)的数学原理</center>
 


<div style="text-align: right;">孙自翔 </div> 
<div style="text-align: right;">haichengsun123@163.com</div> 

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<font face="黑体" size=4> 
<style>
p.caption {
  size=8;
  font-size:100;
}
</style>
**写在前面**: 数字签名算法(DSA)是原始的Elgamal数字签名算法的变体，Elgamal数字签名算法是基于离散对数公钥密码体系的算法。本文旨在不引入`群论`的情况下，在离散对数相关概念(阶，原根)的基础上，用朴素的数论知识阐述Elgamal和DSA数字签名算法.本文既能充分阐述算法所需要的数学知识，又不拘泥于细节；既能阐述其推导过程，又不过分扩展无关知识。非常适合程序员或公钥加密算法爱好者阅读。
   
 


<!--
这里是注释显示不出来
{\rm 需转换的部分字符}
$$ evidence\_{i}=\sum \_{j}W\_{ij}x\_{j}+b\_{i} $$
其中，\\( W\_i \\) 和 \\( b\_i \\) 分别为类别 \\( i \\) 的权值和偏置。
\\( {\cal  K}   {\rm A}   \alpha　A　\beta　B　\gamma　\Gamma　\delta　\Delta　\epsilon　E \varepsilon　　\zeta　Z　\eta　H　\theta　\Theta　\vartheta \iota　I　\kappa　K　\lambda　\Lambda　\mu　M　\nu　N \xi　\Xi　o　O　\pi　\Pi　\varpi　　\rho　P \varrho　　\sigma　\Sigma　\varsigma　　\tau　T　\upsilon　\Upsilon \phi　\Phi　\varphi　　\chi　X　\psi　\Psi　\omega　\Omega  \\))
\\({\cal K} {\sf K}\\)
\\[\alpha\\]    
\in 
a^b
 
\\(
y=\begin{cases}
-x,\quad x\leq 0  \\\\ 
x, \quad x>0 
\end{cases}
\\)

$$
  \begin{matrix}
   1 & 2 & 3 \\\\
   4 & 5 & 6 \\\\
   7 & 8 & 9
  \end{matrix} 
$$
--> 
##**`1. 概述`**  
<!-- <ol>  加上这里 一级标题不能对齐-->

###**`1.1 离散对数问题`（\\(DLP\\)）**
DSA数字签名算法所依赖的数学根基为**离散**对数问题，先阐述如下，本篇文章即围绕此定义展开。     

**定义** 假设\\(m\\)是一个有原根\\(r\\)的正整数。如果正整数\\(a\\)满足\\((a,m)=1\\),则使得同余式   
$$r^x \equiv  a \ \ mod \ m \ \ \  ( 1 \le x \le \varphi(m) )$$
成立的唯一整数\\(x\\)称为**\\(a对模m的以r为底的指数\\)**或者叫**离散对数**，并且记为\\(ind\_{r}a\\),此处并未标明\\(m\\),因为我们假定其取定值。
    
**说明** 定义中的\\(m\\)不一定为素数，而且如果定义中\\(r\\)非`原根`而仅仅是普通的`阶`的情况，文中也会阐述。        
面对此定义及说明，我们自然有如下问题:    
1. 什么是`阶`?  
2. 什么是`原根`?   
3. 为什么一定有满足上述定义的\\(x\\)存在，且唯一? 
   
本文的目的就是为了清晰的阐述这一定义。 并在此基础上阐述Elgamal数字签名算法和DSA数字签名算法。  
 

### `1.2 了解原根等相关知识的必要性`

上述定义已经展示，要理解此定义及证明\\(x\\)的存在性，必须了解原根等相关知识。


### `1.3 是否一定要了解群论相关知识`    
只了解数论相关知识，而不了解群论，一样可以把Elgamal加密算法和DSA数字签名算法（DSA）阐述清楚。 当然如果了解群论，对于问题的描述更加便捷，但本文使用`集合`而非`群论`中的概念来描述。   

*****

## `2. 原根`
 
介绍`原根`，需要先介绍`阶`的概念，从而需要先复习下`欧拉定理`，重述如下:
### `2.1 欧拉定理`      
**定义** 设\\(n\\)是一个正整数，**欧拉\\(\varphi函数\varphi(n)\\)**定义为不超过\\(n\\)且与\\(n\\)互素的正整数的个数。
<center> 欧拉函数\\(\varphi(n)\\)的值， \\(1\leq n \leq 12\\)  </center>  

|               n|   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|\\(\varphi(n)\\)|   1|   1|   2|   2 |   4|   2|   6|   4|   6|   4|  10|   4|


**欧拉定理** 设\\(m\\)是一个正整数，\\(a\\)是一个整数且\\((a,m)=1\\),那么\\(a^{\varphi(m)}\equiv 1(mod\ m)\\)  
**证明** 参考《初等数论及其应用》

**一点说明**
> \\(这里的a和m不要求为素数，只要满足(a,m)=1\\)
> 而费马小定理则要求模数是素数.
>

**举例说明**

>\\(令a = 4， m = 9，满足(a,m)=1且\varphi(9)=6\\)       
>此时有
>\\(a^{\varphi(m)} =4^{6}=4096 \equiv 1(mod \ 9)\\)


**举例说明**
> 
> \\(7x \equiv 1(mod\ 10)，求x\\)    
> \\(令a=7，m=10，此时有(a,m)=1，\varphi(m)=\varphi(10)=4，所以\\)    
> \\(7模10的逆为7^{\varphi(10)-1}=7^{3}=343\equiv 3(mod\ 10)\\)    
> \\(所以7模10的逆x\equiv 3(mod10)\\)


### `2.2 整数的阶`
**定义** 设\\(a\\)和 \\(n\\)是互素的整数，\\(a \not=0,n>0  \\).使得\\(a^x \equiv 1 (mod \  n)\\)成立的最小正整数\\(x\\)称为\\(a模n的阶\\)，并记为\\(ord\_{n}a\\).   
      
**说明:** 根据欧拉定理，如果\\(n\\)为正整数且\\(a\\)是一个和\\(n\\)互素的整数，那么\\(a^{\varphi(n)}\equiv 1(mod\ n)\\)，因此至少存在一个整数\\(x\\)满足这个同余方程.所以存在一个最小的正整数\\(x\\)满足这个同余方程\\(a^x \equiv 1 (mod \ n)\\)，故有如上定义。   

      
**示例1:**  为求出2模7的阶，我们计算2的各次幂模7的最小正剩余，有：

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$2^k(mod \ 7)$$|   2|   4|   1|   2 |   4|   1|   2|   4|   1|   2|   4|   1|        

因此有\\(ord\_{7}2 =3\\), 注意此时 \\(ord\_{7}2 < \varphi(7)=6\\),    
    
**示例2:** 为求出3模7的阶，我们计算3的各次幂模7的最小正剩余，有：      
         
 
|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$3^k(mod \ 7)$$|   3|   2|   6|   4 |   5|   1|   3|   2|   6|   4|  5|   1|


 因此有\\(ord\_{7}3 =6\\), 注意此时 \\(ord\_{7}3 = \varphi(7)=6\\),  
         所以并不总是有    \\(ord\_{n}a = \varphi(n)\\), 跟 \\(a\\)的具体值有关.      
                    
给特定一个整数\\(n\\), 我们对模\\(n\\)阶为\\(\varphi(n)\\)的整数\\(a\\)感兴趣，也即模\\(n\\)的最大可能阶(\\(ord\_{n}a = \varphi(n)\\))。从而引出原根的定义。          
### `2.3 原根`  
**定义2.3.1** 如果\\(r\\)和 \\(n\\)是互素的整数，且\\(n>0  \\).那么当\\(ord\_{n}a = \varphi(n)\\)时，称\\(r\\)是**模\\(n\\)的原根**或者**\\(n\\)的原根**  
**说明** 原根的定义之所以重要，是因为原根有着很好的性质，特别是当\\(n\\)为素数时。现在先不加证明的给出什么样的正整数存在原根，随后给出若干原根的例子，再给出关于原根的若干定理。 
 
**定理2.3.1** 正整数\\(n(n>1)\\)有原根当且仅当     
     $$n=2,4,p^t或者2p^t$$
     其中\\(p\\)为奇素数且\\(t\\)是正整数.      
**说明**  由此定理可知，在前30个数中，有原根的数为    
$$2,3,4,5,6,7,9,10,11,13,14,17,18,19,22,23,25,26,27,29$$
我们只说明这些正整数有原根，但是没有给出原根是什么。下面给出几个原根示例。    
**示例1** 10有原根，原根必然和10互素，可能为3,7,9，且\\(\varphi(10)=4\\),计算如下    

**$$r=3时$$**       


|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$3^k(mod\ 10)$$|   3|   9|   7|    1|   3|   9|   7|   1|   3|   9|  7|   1|



可以看出\\(ord\_{10}3=4=\varphi(10)\\)),所以3是10的原根,且其`余数`是循环的，集合为{3,9,7,1}，构成了模10的既约剩余系。
**$$r=7时$$**     

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$7^k(mod\ 10)$$|   7|   9|   3|    1|   7|   9|   3|   1|   7|   9|  3|   1|

可以看出\\(ord\_{10}7=4=\varphi(10)\\)),所以7是10的原根,且其`余数`是循环的，集合为{3,9,7,1}，构成了模10的既约剩余系。

**$$r=9时$$**      

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$9^k(mod\ 10)$$|   9|   1|   9|    1|   9|   1|   9|   1|   9|   1|   9|   1|

可以看出\\(ord\_{10}9=2\not=\varphi(10)\\)),所以9不是10的原根.    
所以10的原根只有2个{3,7}, 个数\\(2=\varphi(\varphi(10))=\varphi(4)\\).


**示例2** 素数7有原根，原根必然和7互素，可能为2,3,4,5,6, 且\\(\varphi(7)=6\\),计算如下    

**$$r=2时$$**      


|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$2^k(mod\ 7)$$ |   2|   4|   1|    2|   4|   1|   2|   4|   1|   2|   4|   1|


可以看出\\(ord\_{7}2=3\not=\varphi(7)\\)),所以2不是7的原根。虽然如此,其余数仍然是循环的，集合为\\(\\{1,2,4\\}\\).

**$$r=3时$$**  


|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$3^k(mod\ 7)$$ |   3|   2|   6|    4|   5|   1|   3|   2|   6|   4|   5|   1|


可以看出\\(ord\_{7}3=6=\varphi(7)\\)),所以3是7的原根,且其`余数`是循环的，集合为{3,2,6,4,5,1}，构成了模7的既约剩余系。

**$$r=4时$$**  


|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$4^k(mod\ 7)$$ |   4|   2|   1|    4|   2|   1|   4|   2|   1|   4|   2|   1|

可以看出\\(ord\_{7}4=3\not=\varphi(7)\\)),所以4不是7的原根,其余数集合为\\(\\{4,2,1\\}\\). 
**$$r=5时$$**  



|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$5^k(mod\ 7)$$ |   5|   4|   6|    2|   3|   1|   5|   4|   6|   2|   3|   1|


可以看出\\(ord\_{7}3=6=\varphi(7)\\)),所以5是7的原根,且其`余数`是循环的，集合为{5,4,6,2,3,1}，构成了模7的既约剩余系。

**$$r=6时$$** 

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$6^k(mod\ 7)$$ |   6|   1|   6|    1|   6|   1|   6|   1|   6|   1|   6|   1|


可以看出\\(ord\_{7}6=2\not=\varphi(7)\\)),所以6不是7的原根,其余数集合为\\(\\{6,1\\}\\)   
  
所以7的原根有2个{3,5}, 个数\\(2=\varphi(\varphi(7))=\varphi(6)\\)
*****

## `3. 原根的性质`
**定理3.1** 如果\\(r\\)和 \\(n\\)是互素的正整数，且\\(n>0  \\).则如果\\(r\\)是**模\\(n\\)**的一个原根，那么下列整数     
$$r^1,r^2,...,r^{\varphi(n)}$$     
构成了模\\(n\\)的既约剩余系.        
**说明** 上面给出10和7的原根的计算过程，已经诠释了这一定理。重述如下：        
\\(ord\_{10}3=4=\varphi(10)\\)),3是10的原根,且其`余数`是循环的，集合为{3,9,7,1}，构成了模10的既约剩余系。       
\\(ord\_{10}7=4=\varphi(10)\\)),7是10的原根,且其`余数`是循环的，集合为{3,9,7,1}，构成了模10的既约剩余系。


\\(ord\_{7}3=6=\varphi(7)\\)),3是7的原根,且其`余数`是循环的，集合{3,2,6,4,5,1}，构成了模7的既约剩余系。
\\(ord\_{7}3=6=\varphi(7)\\)),5是7的原根,且其`余数`是循环的，集合{5,4,6,2,3,1}，构成了模7的既约剩余系。
    
这其实是一个包含了\\(\varphi(n)\\)个元素的集合，且是循环的.

**定理3.2** 如果正整数 \\(n\\)有一个原根，那么它一共有\\(\varphi(\varphi(n))\\)个不同的原根。     
这个定理不是本文所关注的，是一个附加定理，可以忽略。     


**说明** 上面给出10和7的原根的计算过程，已经诠释了这一定理。重述如下：        
10的原根有2个{3,7}, 个数\\(2=\varphi(\varphi(10))=\varphi(4)\\)    
7的原根有2个{3,5}, 个数\\(2=\varphi(\varphi(7))=\varphi(6)\\)  

到此为止，我们已经可以充分理解文章开头给出的离散对数的定义中给出的前三个问题。也能完全阐述清楚Elgamal签名算法的原理，但是工程在用的DSA算法是Elgamal签名算法的扩展，涉及到`阶`的相关性质。

   
## `4. 阶的相关性质`

在上文中计算10的原根的过程中，发现并非所有和10互素的数{3,7,9}都是10的原根，那么非原根的那些数字有什么特点呢，这里为后面`阶`的性质做铺垫。    
以\\(n=11\\)为例计算原根，进一步巩固前面的知识,并且观察研究不是原根的这些数字的特点。
$$r=2$$   

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$2^k(mod\ 11)$$ |   2|   4|   8|    5|   10|   9|   7|   3|   6|   2|   4|   8|

$$r=3$$    

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$3^k(mod\ 11)$$ |   3|   9|   5|    4|   1|   3|   9|   5|   4|   1|   3|   9|


$$r=4$$

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$4^k(mod\ 11)$$ |   4|   5|   9|    3|   1|   4|   5|   9|   3|   1|   4|   5|


$$r=5$$

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$5^k(mod\ 11)$$ |   5|   3|   4|    9|   1|   5|   3|   4|   9|   1|   5|   3|

$$r=6$$

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$6^k(mod\ 11)$$ |   6|   3|   7|    9|   10|   5|   8|   4|   2|   6|   3|   7|

$$r=7$$

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$7^k(mod\ 11)$$ |   7|   5|   2|    3|   10|   4|   6|   9|   8|   7|   5|   2|

$$r=8$$

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$8^k(mod\ 11)$$ |   8|   9|   6|    4|   10|   3|   2|   5|   7|   1|   8|   9|

$$r=9$$

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$9^k(mod\ 11)$$ |   9|   4|   3|    5|   1|   9|   4|   3|   5|   1|   9|   4|

$$r=10$$

|  \\(k\\)       |   1|   2|   3|   4 |   5|   6|   7|   8|   9|  10|  11|  12|
|            :--:|:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$10^k(mod\ 11)$$ |   10|   1|   10|    1|   10|   1|   10|   1|   10|   1|   10|   1|


**总结如下**    
**1.** 11的原根有\\(\varphi(\varphi(11))=\varphi(10)=4\\)个，分别为\\(2,6,7,8\\),原根又叫做生成元，每个生成元都可以生成\\(\varphi(11)=10\\)个元素，这些元素\\(\\{1,2,3,4,5,6,7,8,9,10\\}\\)构成了模11的既约剩余系。    
**2.** 剩余的和11互素的数\\(\\{3,4,5,9,10\\}\\)都不是11的原根。我们以9和10作为例子观察。    
**3.** 当\\(r=9\\)时         
\\(9^5 \equiv 1 mod 11=> ord\_{11}9=5\\),也就是9模11的阶为5，此时由\\(r=9模11\\)生成的数为一个集合，集合的个数为\\(ord\_{11}9=5\\)，分别为\\(\\{1,3,4,5,9\\}\\)        
**4.** 当\\(r=10\\)时        
\\(10^2 \equiv 1 mod 11=> ord\_{11}10=2\\),也就是10模11的阶为2，此时由\\(r=10模11\\)生成的数为一个集合，集合的个数为\\(ord\_{11}10=2\\)，分别为\\(\\{1,10\\}\\)  
**5.** 由模11的阶生成的集合的个数只可能为\\(2，5，10\\),恰好等于阶的的大小，且都能被\\(\varphi(11)=10\\)整除. 

    
结合以上总结，给出`阶`的若干性质。

**定理4.1** 如果 \\(a\\)和\\(n\\)是互素的整数，且\\(n>0\\)，那么\\(ord\_{n}a|\varphi(n)\\)。     
**说明** 对照上面的例子当\\(n=11\\)时\\(\varphi(11)=10\\),被10整除的数只有\\(\\{2,5,10\\}\\),所以模11的`阶`\\(ord\_{n} r=s\\)只可能为\\(\\{2,5,10\\}\\)，且每个数\\(r\\)都生成了\\(ord\_{n} r=s\\)个数,符合预期。 可以总结为  
**$$满足ord\_{n}r=s的数r生成了s个数,也就是阶为s则生成的数的集合个数也是s, 称r是阶为s的生成元$$**


以\\(n=11\\)重述如下：    
**1.** \\(ord\_{11}2=10\\)，\\(r=2\\)时阶为10，生成的元素个数也是10，分别为\\(\\{1,2,3,4,5,6,7,8,9\\}\\)        
**2.** \\(ord\_{11}9=5\\)，\\(r=9\\)时阶为5，生成的元素个数也是5，分别为\\(\\{1,3,4,5,9\\}\\)              
**3.** \\(ord\_{11}10=2\\)，\\(r=10\\)时阶为2，生成的元素个数也是1，分别为\\(\\{1,10\\}\\) 

所以可以通过\\(\varphi(n)\\)找到\\(n\\)的所有的阶，均为\\(\varphi(n)\\)的因子。 


**定理4.2** 如果\\(a\\)和\\(n\\)是互素的整数，且\\(n>0\\)，那么\\(a^i \equiv a^j \ (mod \ n)\\) 当且仅当 \\(i \equiv j ( mod \ ord\_{n}a)\\),其中\\(i\\)和\\(j\\)是非负整数。        

结合**定理4.1**的结论，假设\\(p\\)是一个素数，  \\(\varphi(p)=p-1\\) ,所以可以通过计算\\(p-1\\)的因子，寻找\\(n\\)的阶，且其中必有素数,也就是计算 \\(\varphi(p)=p-1\\) 的素除数。   
所以计算\\(阶\\)也就是计算\\(p-1\\)的因子。        
> ####阶为\\(p-1\\)本身,即存在\\(p\\)的原根\\(a\\)使得。 \\(\varphi(p)=p-1=ord\_{p}a\\)         
> ####阶为\\(q, \ \ q<p-1\\)，\\(q\\)是\\(p-1\\)的一个真因子(且必有素因子)，存在\\(b\\)使得 \\(q=ord_{p}b\\),此时由\\(b\\)生成了一个大小为\\(q\\)的集合。  



根据以上两种情况可以有如下推论:    

**推论4.2.1**  如果整数\\(a\\)是素数\\(p\\)的一个原根，那么\\(a^i \equiv a^j \ (mod \ p) \\) 当且仅当 \\(i \equiv j \ (mod \varphi(p))\\), 也就是 \\(i \equiv j \ (mod \ （ p-1）)\\)，其中\\(i\\)和\\(j\\)是非负整数。  

**推论4.2.2**  如果阶为\\(q\\)，\\(q\\)是\\(p-1\\)的一个真因子， \\(q=ord\_{p}b\\)(也就是\\(b是阶为q的一个生成元\\)),那么\\(b^i \equiv b^j \ (mod \ p) \\) 当且仅当 \\(i \equiv j \ (mod \ q)\\),其中\\(i\\)和\\(j\\)是非负整数。   


上面两个推论即分别为`Elgama签名算法`和`DSA签名算法`生成步骤和证明的一个关键所在。

        
        
数论知识介绍到这里，足以推导出后面的`Elgama签名算法`和`DSA签名算法`。

*****

## `5. Elgama签名算法`   
Elgamal签名方案最早于1985年发布，它是基于计算离散对数的难度。      

**5.1 密钥生成**
与其他所有公钥方案一样，教科书式的Elgamal数字签名方案也存在一个握手阶段，在此期间计算密钥。首先找到一个大素数\\(p\\)，并使用如下步骤构建一个离散对数问题。  

      
**Elgamal数字签名的密钥生成**    
1. 选择一个大素数\\(p\\)       
2. 选择\\(Z\_p\\)的一个生成元(本原元)    
3. 选择随机整数\\(d \in \\{2,3,...,p-2\\}\\)      
4. 计算\\(\beta  = \alpha^d \ mod p\\)    

\\(k\_{pub}=(p,\alpha,\beta)形成了公钥，而k\_{pr}=d则是私钥\\)


**5.2 签名与验证**
使用私钥和公钥的参数就可以得到每个消息\\(x\\)的签名为：
$$sig{\_{{p}\_{pr}}}(x,k\_{E})=(r,s)$$   

这个计算是在签名过程中得到的。请注意：此签名由两个整数\\(r\\)和\\(s\\)构成。而签名过程则包含两个主要步骤：选择一个构成临时私钥的随机值\\(k\_E\\)和计算\\(x\\)的实际签名。

**Elgama签名生成**    
1. 从2到\\(p-2\\)选择一个随机的密钥\\(k\_E\\),使得\\(gcd(k\_E, p-1)=1\\)    
2. 计算签名参数:
   $$r\equiv \alpha^{k\_E} \ mod \ p$$
   $$s\equiv(x-d\cdot r)k\_{E}^{-1} mod \ (p-1)$$
\\((r,s)即是x的签名\\)


接收方使用公钥和签名，通过函数\\(ver{\_{k\_{pub}}}(x,(r,s))\\)对签名进行验证。     


**Elgama签名验证**    
1. 计算值
 $$t\equiv\beta^r\cdot r^s \ mod \ p$$
2. 验证过程为：

$$
t\begin{cases}
\equiv \alpha^x mod \ p \ \ \ \  \Rightarrow  \ \ \ \ 有效的签名\\\\ 
\not \equiv \alpha^x mod \ p \ \ \ \  \Rightarrow  \ \ \ \  无效的签名 
\end{cases}
$$

 
简而言之，只有在关系式$$\beta^r\cdot r^s \equiv \alpha^x \ mod \ p$$
满足时，接收方才会接受签名否则验证失败。下面给出证明：

**证明:** 验证方程为:
$$\alpha^x   \equiv \beta^r\cdot r^s \ mod \ p$$
即证明:    
$$\alpha^x   \equiv \beta^r\cdot r^s \equiv (\alpha^d)^r(\alpha^{k\_E})^s \equiv \alpha^{dr+k\_Es}\ mod \ p$$
也就是:
$$\alpha^x  \equiv \alpha^{dr+k\_Es}\ mod \ p$$
根据`推论4.2.1`,如下关系式成立:    
$$x  \equiv {dr+k\_Es}\ mod \ (p-1)$$
进而可以得到数字签名参数\\(s\\)的构建规则：
$$s\equiv(x-d\cdot r )k\_E^{-1} mod(p-1)$$
由于在计算\\(s\\)时需要将临时密钥模\\(p-1\\)求逆所以必须满足条件
$$gcd(k\_E, p-1)=1$$  
至此，上述方程得证。

**5.2 实例** 下面给出一个Elgamal签名处理较小整数的例子。      
Bob想发送一个消息给Alice，使用Elgama数字签名方案对消息进行签名。对应的签名和验证过程为:    

 
　　　　　　　　　　　　\\(Alice\\)　　　　　　　　　　　　\\(Bob\\) 　　　　　　　　　
    
　　　　　　　　　　　　　　　　　　　　　　　　　　1.选择\\(p=29\\)      
　　　　　　　　　　　　　　　　　　　　　　　　　　2.选择\\(\alpha=2\\)   
　　　　　　　　　　　　　　　　　　　　　　　　　　3.选择\\(d=12\\)      
　　　　　　　　　　　　　　　　　　　　　　　　　　4.选择\\(\beta=\alpha^d\equiv=29\\)   
$$
\underleftarrow{\text{\\((p,\alpha,\beta)=(29,2,7)\\)}}
$$   
　　　　　　　　　　　　　　　　　　　　　　　　　　计算消息\\(x=26\\)的签名     
　　　　　　　　　　　　　　　　　　　　　　　　　　选择\\(k\_E=5,使得gcd(5,28)=1\\),
　　　　　　　　　　　　　　　　　　　　　　　　　　\\(r=\alpha^{k\_E}\equiv 2^5\equiv 3mod29\\) 　　
　　　　　　　　　　　　　　　　　　　　　　　　　　\\(s=(x-dr)k\_E^{-1}\equiv(-10)\cdot 17\equiv 26mod28\\)   
$$
\underleftarrow{\text{\\((x(r,s))=(26,(3,26))\\)}}
$$ 　　
\\(Alice\\)验证:        
\\(t=\beta^r\cdot r^s\equiv 7^3\cdot3^{26} \equiv 22 mod 29\\)　
\\(\alpha^x\equiv2^{26}\equiv 22 mod29\\)　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
\\(t=\alpha^x mod 29 \ \  \Rightarrow \ \  有效的签名 \\)　            
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
******

# `6. DSA数字签名算法`
上面描述的Elgamal数字签名算法在实际中很少使用。相反，常用的是一种更为流行的变体,即数字签名算法(DSA),此算法是联邦美国政府在数字签名方面的标准，并有国家标准与技术局(NIST)提出.数字签名算法比Elgamal数字签名方案优胜的地方在于，其签名长度仅为320位，而且某些可以破解Elgamal方案的攻击却不适用于此方案.        

Elgamal签名算法和DSA数字签名算法在数学证明上的差异参考`推论4.2.1`和`4.2.2`.        
**`6.1 DSA算法`**     
这里主要介绍长度为1024位的DSA标准。注意：标准也允许更长的密钥长度.    

**`1. 密钥生成`**    
DSA密钥的计算方式如下:     

**DSA的密钥生成**    
1. 生成一个素数\\(p\\),且 \\(2^{1023} \le p \le 2^{1024}\\)    
2. 找到\\(p-1\\)的一个素除数\\(q\\), 且\\(2^{159} \le p \le 2^{160}\\)       
3. 找到\\(ord\_p(\alpha)=q的元素\alpha\\), 即\\(\alpha\\)生成了拥有\\(q\\)个元素的一个集合。    
4. 选择一个随机整数\\(d\\),且 \\( 0 \le d \le q\\)    
5. 计算\\(\beta \equiv \alpha^d mod \ p\\)    
则密钥为:       
\\(k\_{pub}=(p,q,\alpha,\beta)\\)    
\\(k\_{pr}=(d)\\)    

**以29作为例子**


**`2. 签名与验证`**    
与Elgamal数字签名方案相同，DSA签名也包含一对整数\\((r,s)\\). 由于这两个参数的长度都是160位，所以签名总长度为320位。使用公钥和私钥对消息\\(x\\)签名的计算方法为:        

**`DSA签名生成`**
1. 选择一个整数作为随机临时密钥\\(k\_E\\), 且满足\\(0 \le k\_E \le q\\)，由于\\(q\\)是素数，所以隐含\\(gcd(k\_E, q)=1\\)    
2. 计算签名参数:
   $$r\equiv (\alpha^{k\_E} \ mod \ p) mod \ q$$
   $$s\equiv(SHA(x)+d\cdot r)k\_{E}^{-1} mod \ q$$
\\((r,s)即是x的签名\\)
 
根据标准,为了计算\\(x\\)必须先使用哈希函数SHA-1对消息\\(x\\)进行哈希。

**`DSA签名验证`**    
1. 计算辅助值\\(w=s^{-1} \ mod\ q\\)    
2. 计算辅助值\\(u\_1=w \cdot SHA(x) mod\ q\\)    
3. 计算辅助值\\(u\_2=w \cdot r mod\ q\\)    
4. 计算\\(v \equiv (\alpha^{u\_{1} \cdot  \beta^{u\_2}}mod \ p) modq\\)    
5. 验证函数\\(ver\_{k\_{pub}}(x,(r,x)) \\)的结果为:    

$$
v\begin{cases}
\equiv \ r \ mod q\ \ \ \  \Rightarrow  \ \ \ \ 有效的签名\\\\ 
\not \equiv \ r \   mod q\ \ \ \  \Rightarrow  \ \ \ \  无效的签名 
\end{cases}
$$

只有在满足条件\\(v \equiv r \ mod \ q\\)时，验证者才会接受签名\\((r,s)\\);否则，验证失败。

**`证明`**
要证明\\(v \equiv r\\), 即要证明 \\((\alpha^{u\_1} \cdot \beta^{u\_2} mod\ p) mod \ q \equiv \alpha^{k\_{E}} mod \ p mod \ q\\)      
首先看签名参数\\(s\\)    
$$s\equiv(SHA(x)+d\cdot r)k\_{E}^{-1} mod \ q$$
其等价于:    
$$k\_{E} \equiv s^{-1}SHA(x) + d \cdot s^{-1}r\ mod \ q$$    
右边的值可以使用辅助参值\\(u\_1\\)和\\(u\_2\\)表示    
$$k\_{E} \equiv u\_1 + d \cdot u\_2 mod \ q$$        
根据推`论4.2.2`可得
$$\alpha^{k\_{E}} mod p \equiv \alpha^{u\_1 + d \cdot u\_2} mod \ p$$            
由于公钥值\\(\beta\\)的计算公式为\\(\beta \equiv \alpha^{d} mod \ p\\),上式可以写为:    
$$\alpha^{k\_{E}} mod p \equiv \alpha^{u\_1}\beta^{u\_2} mod \ p$$                
两边同时模\\(q\\)
$$(\alpha^{k\_{E}} mod\ p)mod q \equiv (\alpha^{u\_1}\beta^{u\_2} mod \ p)mod q$$                
命题从而得证。    


**`6.2 实例`** 下面给出一个DSA签名处理较小整数的例子。      
Bob想发送一个消息给Alice，使用DSA数字签名方案对消息进行签名。假设\\(x\\)的hash值为\\(h(x)=26\\), 对应的签名和验证过程为:    

 
　　　　　　　　　　　　\\(Alice\\)　　　　　　　　　　　　\\(Bob\\) 　　　　　　　　　
    
　　　　　　　　　　　　　　　　　　　　　　　　　　1.选择\\(p=59\\)      
　　　　　　　　　　　　　　　　　　　　　　　　　　2.选择\\(q=29\\)      
　　　　　　　　　　　　　　　　　　　　　　　　　　3.寻找到\\(\alpha=3\\)使得\\(ord\_{p}(3)=29\\),后面给出列表. 
　　　　　　　　　　　　　　　　　　　　　　　　　　4.选择私钥\\(d=7\\)      
　　　　　　　　　　　　　　　　　　　　　　　　　　5.从而\\(\beta=\alpha^d\equiv 4 mod 59\\)   
$$
\underleftarrow{\text{\\((p,q,\alpha,\beta)=(59,29,2,7)\\)}}
$$   
　　　　　　　　　　　　　　　　　　　　　　　　　　计算消息\\(h(x)=26\\)的签名     
　　　　　　　　　　　　　　　　　　　　　　　　　　1.选择临时密钥\\(k\_E=10,使得gcd(10,29)=1\\),    
　　　　　　　　　　　　　　　　　　　　　　　　　　2.\\(r=(\alpha^{k\_E}\  mod \ p) mod \ q = (3^{10} mod\ 59)mod\ q \equiv 20 mod \ 29\\)   
　　　　　　　　　　　　　　　　　　　　　　　　　　            　　    
　　　　　　　　　　　　　　　　　　　　　　　　　　3.\\(s\equiv((SHA(x)+d\cdot r)k\_{E}^{-1} mod \ q) \equiv (26+7\cdot20) \cdot 3 \equiv 5 mod\ 29 \\)       
$$
\underleftarrow{\text{\\((x(r,s))=(26,(20,5))\\)}}
$$ 　　
\\(Alice\\)验证:        
1. \\(w=s^{-1} = 5^{-1} \equiv 6 mod\ 29\\)　         
2. \\(u\_{1}=w \cdot SHA(x)=6\cdot 26\equiv 11 mod\ 29\\)        
3. \\(u\_{2}=w \cdot r = 6\cdot 20\equiv 4 mod\ 29\\)　         
4. \\(v=\equiv (\alpha^{u\_{1} \cdot  \beta^{u\_2}}mod \ p) modq=(3^{11}\cdot 4^4 mod \ 59) mod\ 29 = 20\\)    
5. \\(v \equiv r mod 29 \ \  \Rightarrow \ \  有效的签名 \\)　                    

**`6.3 几点说明`**         
1. 上例中\\(p=59\\), \\(q\\)的值为什么可以取29?        
>根据 **定理4.1** 如果 \\(a\\)和\\(n\\)是互素的整数，且\\(n>0\\)，那么\\(ord\_{n}a|\varphi(n)\\)。        
由于\\(p=59\\)是素数,  则\\(ord\_{59}a|\varphi(59)\\),也就是\\(ord\_{59}a|58\\)        
\\(58=2\cdot29\\), 所以\\(q\\)的取值只可能是2或者29    
更一般的，如果\\(p\\)是素数,则 \\(\frac{\varphi(n)-1}{2}=\frac{p-1}{2}\\) 一定是\\(p\\)的一个阶。         



2.\\(ord\_{59}(3)=29\\)    

|  \\(k\\)        |   1|   2|   3|    4|   5|   6|   7|   8|   9|  10|  11|  12| 
|            :--: |:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$3^k(mod\ 59)$$ |   3|   9|  27|   22|   7|  21|   4|  12|  36|  49|  29|  28| 

|  \\(k\\)        |  13|  14|  15|   16|  17|  18|  19|  20|  21|  22|  23|  24| 
|            :--: |:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$3^k(mod\ 59)$$ | 25|   16|  48|   26|  19|  57|  53|  41|   5|  15|  45|  17| 

|  \\(k\\)        |  25|  26|  27|  28|   29|  30|  31|  32|  33|  34|  35|  36| 
|            :--: |:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$3^k(mod\ 59)$$ |  51|  35|  46|  20|    1|   3|   9|  27|  22|   7|  21|   4| 

|  \\(k\\)        |  37|  38|  39|   40|  41|  42|  43|  44|  45|  46|  47|  48| 
|            :--: |:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$3^k(mod\ 59)$$ |  12|  36|  49|   29|  28|  25|  16|  48|  26|  19|  57|  53| 

|  \\(k\\)        |  49|  50|  51|   52|  53|  54|  55|  56|  57|  58|  59|  60| 
|            :--: |:--:|:--:|:--:| :--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|$$3^k(mod\ 59)$$ |  41|   5|  15|   45|  17|  51|  35|  46|  20|   1|   3|   9| 

可以看出:     
1. \\(p=59, q=29, 当k \in (1,q)时,  3^k(mod\ 59) \in (1,p-1)\\)      
2. 阶为\\(q\\)的生成元\\(\alpha\\)的取值范围为\\(\alpha \in (2,p-1)\\)，而不仅限于\\(\alpha \in (2,q-1)\\)     
下列都是关于59阶为29的生成元
\\(3,4,5,7,9,12,15,16,17,19,20,21,22,25,26,27,28,29,35,36,41,45,46,48,49,51,53,57\\)
这是理解openssl的生成密钥的一个关键.

*****
## `7. openssl实例`
下面给出openssl关于dsa生成密钥的命令。            
openssl dsaparam 用于生成DSA参数，最小长度为512bit,以512bit为例         
有了上面的铺垫，其输出参数就可以阐述清楚了。        
**`1. openssl dsaparam -noout -out dsakey_512.pem -genkey 512`**        
**`2. openssl dsa -in dsakey_512.pem -text`**             
>Private-Key: (512 bit)
priv:        
    60:53:7d:11:f5:2a:c8:61:b3:b3:f3:bd:dd:76:ff:
    22:65:ec:6e:56        
pub:         
    06:18:a8:42:6d:f6:6b:bd:2d:22:10:db:d2:2d:81:
    ec:5e:1b:64:a9:12:a5:7a:87:62:fa:fd:96:1e:a9:
    6e:c0:18:f5:5c:89:3f:fd:d7:c4:94:83:4e:a4:db:
    35:3b:5e:30:69:8d:ca:12:1c:88:9b:2a:3f:0c:54:
    e7:51:6d:bd        
P:        
    00:b9:05:de:ec:c4:a2:ef:4b:3c:0b:61:95:67:6b:
    31:55:aa:43:f3:75:03:4c:4b:54:8c:ca:67:96:ef:
    7d:d9:e7:db:d2:30:40:ce:9f:a5:2d:08:c5:0d:7b:
    43:98:01:f3:eb:c4:0c:69:ae:1f:a9:fe:b1:61:73:
    43:d2:c6:3d:19        
Q:        
    00:94:7a:38:31:fa:f4:4c:80:44:f1:d5:2f:dd:47:
    74:cc:91:6a:1f:2b         
G:        
    00:9b:2d:c1:0e:77:5b:8b:c8:f6:7d:fc:83:77:57:
    6a:f4:c2:a9:85:ac:8d:00:58:43:16:70:7e:fc:b8:
    dd:7c:54:c4:9f:c2:fd:87:99:0a:e8:cc:9b:6b:99:
    16:ec:ca:9d:fb:ae:d6:87:57:ab:60:e1:3a:37:43:
    95:19:18:5b:10        

`3.参数阐述`
>\\(P\\)是所选择的大素数        
\\(Q是G模P的阶，也就是Q是阶，G是其中一个阶为Q的生成元，G^Q\equiv 1 mod \ P\\)        
\\(priv是私钥，pub是公钥，即有G^{priv} \equiv pub \ mod \ P\\)         
\\(Q一定整除\varphi(P)=P-1,也就是 Q|(P-1)\\) ，即 \\(Q \equiv 0 \ mod \ P-1\\)       

`4.参数验证`   
由于python在计算大数的幂时非常慢，我们用C库gmp来验证。     
>```#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <assert.h>
#include "gmp.h"
int main()
{
	mpz_t P;    // 素数
	mpz_t Q;    // Q个元素的子群 
	mpz_t G;    // 生成元
	mpz_t pub;  // 公钥
	mpz_t priv; // 私钥
	mpz_t tmp;  // 临时值
	mpz_t phi_P;    //P的欧拉phi函数为P-1 
	mpz_inits (P ,Q, G, pub, priv, tmp, phi_P, NULL);
	mpz_set_str (P, 
                "0x00b905deecc4a2ef4b3c0b6195676"
                "b3155aa43f375034c4b548cca6796ef"
                "7dd9e7dbd23040ce9fa52d08c50d7b4"
                "39801f3ebc40c69ae1fa9feb1617343"
                "d2c63d19", 0); //  初始化素数
	mpz_set_str (Q, "0x00947a3831faf44c8044f1"
			        "d52fdd4774cc916a1f2b", 0); // 初始化子群个数
	mpz_set_str (G, "0x009b2dc10e775b8bc8f67dfc8"
			        "377576af4c2a985ac8d00584316"
					"707efcb8dd7c54c49fc2fd87990"
					"ae8cc9b6b9916ecca9dfbaed687"
					"57ab60e13a37439519185b10", 0);
	mpz_set_str (priv, "0x60537d11f52ac861b"
			     "3b3f3bddd76ff2265ec6e56", 0);
	mpz_set_str (pub, "0x0618a8426df66bbd2d2210db"
			"d22d81ec5e1b64a912a57a8762fafd961ea9"
			"6ec018f55c893ffdd7c494834ea4db353b5e"
			"30698dca121c889b2a3f0c54e7516dbd", 0);
	mpz_set_str (phi_P, 
                "0x00b905deecc4a2ef4b3c0b6195676"
                "b3155aa43f375034c4b548cca6796ef"
                "7dd9e7dbd23040ce9fa52d08c50d7b4"
                "39801f3ebc40c69ae1fa9feb1617343"
                "d2c63d18", 0); //P-1 
// 验证 (G**Q)%P==1
	mpz_powm(tmp, G, Q, P);
    printf("modulus G^Q % P =  : ");
	mpz_out_str(stdout, 10, tmp);
	printf("\n");
// # 验证公钥私钥
// G^priv)%P=pub
	mpz_powm(tmp, G, priv, P);
// 验证和公钥相等
	int result = mpz_cmp(tmp, pub);
    printf("G^priv \%P = pub|result = : %d\n", result);
//# 验证第一点 Q能整除P-1  Q|(P-1)
// 也就是证明 (P-1)%Q=0
	mpz_mod (tmp, phi_P, Q);
    printf("(P-1)%Q result = : ");
	mpz_out_str(stdout, 10, tmp);
	printf("\n");
}

>编译运行结果    
$ g++ dsa_alg_512.cpp  -lgmp
$ ./a.out
modulus G^Q % P =  : 1
G^priv %P = pub|result = : 0
(P-1)%Q result = : 0
从而验证了密钥的正确性.

*****
**`参考文献`**        
1. 《深入浅出密码学——常用加密技术原理与应用》    
2. 《初等数论及其应用第五版》    

